# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Build Y0 matrix in VAR(p)
#' 
#' @param x Matrix, time series data
#' @param p VAR lag
#' @param t starting index to extract
#' 
#' @details
#' Given data Y,
#' \deqn{Y0 = [y_t^T, y_{t + 1}^T, \ldots, y_{t + n - p - 1}^T]^T}
#' is the (n - p) x m matrix.
#' 
#' In case of Y0, t = p + 1.
#' This function is used when constructing X0.
#' 
#' @references Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
build_y0 <- function(x, p, t) {
    .Call(`_bvhar_build_y0`, x, p, t)
}

#' Build X0 matrix in VAR(p)
#' 
#' @param x Matrix, time series data
#' @param p VAR lag
#' 
#' @details
#' X0 is
#' \deqn{X0 = [Y_p, \ldots, Y_1, 1]}
#' i.e. (n - p) x (mp + 1) matrix
#' 
#' @references Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
build_design <- function(x, p) {
    .Call(`_bvhar_build_design`, x, p)
}

#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
diag_misc <- function(x) {
    .Call(`_bvhar_diag_misc`, x)
}

#' Construct Dummy response for Minnesota Prior
#' 
#' Define dummy Y observations to add for Minnesota moments.
#' 
#' @param p integer, VAR lag. For VHAR, put 3.
#' @param sigma vector, standard error of each variable
#' @param lambda double, tightness of the prior around a random walk or white noise
#' @param delta vector, prior belief about white noise (Litterman sets 1)
#' 
#' @details
#' Bańbura et al. (2010) defines dummy observation and augment to the original data matrix to construct Litterman (1986) prior.
#' 
#' @references
#' Litterman, R. B. (1986). \emph{Forecasting with Bayesian Vector Autoregressions: Five Years of Experience}. Journal of Business & Economic Statistics, 4(1), 25. \url{https://doi:10.2307/1391384}
#' 
#' Bańbura, M., Giannone, D., & Reichlin, L. (2010). \emph{Large Bayesian vector auto regressions}. Journal of Applied Econometrics, 25(1). \url{https://doi:10.1002/jae.1137}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
build_ydummy <- function(p, sigma, lambda, delta) {
    .Call(`_bvhar_build_ydummy`, p, sigma, lambda, delta)
}

#' Construct Dummy design matrix for Minnesota Prior
#' 
#' Define dummy X observation to add for Minnesota moments.
#' 
#' @param p integer, VAR lag. For VHAR, put 3.
#' @param sigma vector, standard error of each variable
#' @param lambda double, tightness of the prior around a random walk or white noise
#' @param eps double, very small number
#' 
#' @details
#' Bańbura et al. (2010) defines dummy observation and augment to the original data matrix to construct Litterman (1986) prior.
#' 
#' @references
#' Litterman, R. B. (1986). \emph{Forecasting with Bayesian Vector Autoregressions: Five Years of Experience}. Journal of Business & Economic Statistics, 4(1), 25. \url{https://doi:10.2307/1391384}
#' 
#' Bańbura, M., Giannone, D., & Reichlin, L. (2010). \emph{Large Bayesian vector auto regressions}. Journal of Applied Econometrics, 25(1). \url{https://doi:10.1002/jae.1137}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
build_xdummy <- function(p, lambda, sigma, eps) {
    .Call(`_bvhar_build_xdummy`, p, lambda, sigma, eps)
}

#' Parameters of Normal Inverted Wishart Prior
#' 
#' Given dummy observations, compute parameters of Normal-IW prior for Minnesota.
#' 
#' @param x_dummy Matrix, dummy observation for X0
#' @param y_dummy Matrix, dummy observation for Y0
#' 
#' @details
#' Minnesota prior give prior to parameters \eqn{B} (VAR matrices) and \eqn{\Sigma_e} (residual covariance) the following distributions
#' 
#' \deqn{B \mid \Sigma_e, Y_0 \sim MN(B_0, \Omega_0, \Sigma_e)}
#' \deqn{\Sigma_e \mid Y_0 \sim IW(S_0, \alpha_0)}
#' (MN: \href{https://en.wikipedia.org/wiki/Matrix_normal_distribution}{matrix normal}, IW: \href{https://en.wikipedia.org/wiki/Inverse-Wishart_distribution}{inverse-wishart})
#' 
#' Bańbura et al. (2010) provides the formula how to find each matrix to match Minnesota moments.
#' 
#' @references
#' Litterman, R. B. (1986). \emph{Forecasting with Bayesian Vector Autoregressions: Five Years of Experience}. Journal of Business & Economic Statistics, 4(1), 25. \url{https://doi:10.2307/1391384}
#' 
#' Bańbura, M., Giannone, D., & Reichlin, L. (2010). \emph{Large Bayesian vector auto regressions}. Journal of Applied Econometrics, 25(1). \url{https://doi:10.1002/jae.1137}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
minnesota_prior <- function(x_dummy, y_dummy) {
    .Call(`_bvhar_minnesota_prior`, x_dummy, y_dummy)
}

#' Construct Dummy response for Second Version of BVHAR Minnesota Prior
#' 
#' Define dummy Y observations to add for Minnesota moments.
#' This function also fills zero matrix in the first block for applying to VHAR.
#' 
#' @param sigma vector, standard error of each variable
#' @param lambda double, tightness of the prior around a random walk or white noise
#' @param daily vector, instead of delta vector in the original Minnesota design (Litterman sets 1).
#' @param weekly vector, this was zero in the original Minnesota design
#' @param monthly vector, this was zero in the original Minnesota design
#' 
#' @details
#' Bańbura et al. (2010) defines dummy observation and augment to the original data matrix to construct Litterman (1986) prior.
#' 
#' @references
#' Litterman, R. B. (1986). \emph{Forecasting with Bayesian Vector Autoregressions: Five Years of Experience}. Journal of Business & Economic Statistics, 4(1), 25. \url{https://doi:10.2307/1391384}
#' 
#' Bańbura, M., Giannone, D., & Reichlin, L. (2010). \emph{Large Bayesian vector auto regressions}. Journal of Applied Econometrics, 25(1). \url{https://doi:10.1002/jae.1137}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
build_ydummy_bvhar <- function(sigma, lambda, daily, weekly, monthly) {
    .Call(`_bvhar_build_ydummy_bvhar`, sigma, lambda, daily, weekly, monthly)
}

#' BVAR(p) Point Estimates based on Minnesota Prior
#' 
#' Point estimates for posterior distribution
#' 
#' @param x Matrix, X0
#' @param y Matrix, Y0
#' @param x_dummy Matrix, dummy X0
#' @param y_dummy Matrix, dummy Y0
#' 
#' @details
#' Augment originally processed data and dummy observation.
#' OLS from this set give the result.
#' 
#' @references
#' Litterman, R. B. (1986). \emph{Forecasting with Bayesian Vector Autoregressions: Five Years of Experience}. Journal of Business & Economic Statistics, 4(1), 25. \url{https://doi:10.2307/1391384}
#' 
#' Bańbura, M., Giannone, D., & Reichlin, L. (2010). \emph{Large Bayesian vector auto regressions}. Journal of Applied Econometrics, 25(1). \url{https://doi:10.1002/jae.1137}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
estimate_bvar_mn <- function(x, y, x_dummy, y_dummy) {
    .Call(`_bvhar_estimate_bvar_mn`, x, y, x_dummy, y_dummy)
}

#' BVAR(p) Point Estimates based on Nonhierarchical Matrix Normal Prior
#' 
#' Point estimates for Ghosh et al. (2018) nonhierarchical model for BVAR.
#' 
#' @param x Matrix, X0
#' @param y Matrix, Y0
#' @param U Positive definite matrix, covariance matrix corresponding to the column of the model parameter B
#' 
#' @details
#' In Ghosh et al. (2018), there are many models for BVAR such as hierarchical or non-hierarchical.
#' Among these, this function chooses the most simple non-hierarchical matrix normal prior in Section 3.1.
#' 
#' @references
#' Ghosh, S., Khare, K., & Michailidis, G. (2018). \emph{High-Dimensional Posterior Consistency in Bayesian Vector Autoregressive Models}. Journal of the American Statistical Association, 114(526). \url{https://doi:10.1080/01621459.2018.1437043}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
estimate_mn_flat <- function(x, y, U) {
    .Call(`_bvhar_estimate_mn_flat`, x, y, U)
}

#' Compute VAR(p) Coefficient Matrices and Fitted Values
#' 
#' @param x X0 processed by \code{\link{build_design}}
#' @param y Y0 processed by \code{\link{build_y0}}
#' @details
#' Given Y0 and Y0, the function estimate least squares
#' Y0 = X0 B + Z
#' 
#' @references Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
estimate_var <- function(x, y) {
    .Call(`_bvhar_estimate_var`, x, y)
}

#' Covariance Estimate for Residual Covariance Matrix
#' 
#' Plausible estimator for residual covariance.
#' 
#' @param z Matrix, residual
#' @param num_design Integer, s = n - p
#' @param dim_design Ingeger, k = mp + 1
#' @details
#' See Lütkepohl (2007).
#' 
#' @references Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
compute_cov <- function(z, num_design, dim_design) {
    .Call(`_bvhar_compute_cov`, z, num_design, dim_design)
}

#' Convert VAR to VMA(infinite)
#' 
#' Convert VAR process to infinite vector MA process
#' 
#' @param object \code{varlse} object by \code{\link{var_lm}}
#' @param lag_max Maximum lag for VMA
#' @details
#' Let VAR(p) be stable.
#' \deqn{Y_t = c + \sum_{j = 0} W_j Z_{t - j}}
#' For VAR coefficient \eqn{B_1, B_2, \ldots, B_p},
#' \deqn{I = (W_0 + W_1 L + W_2 L^2 + \cdots + ) (I - B_1 L - B_2 L^2 - \cdots - B_p L^p)}
#' Recursively,
#' \deqn{W_0 = I}
#' \deqn{W_1 = W_0 B_1}
#' \deqn{W_2 = W_1 B_1 + W_0 B_2}
#' \deqn{W_j = \sum_{j = 1}^k W_{k - j} B_j}
#' 
#' @references Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
VARtoVMA <- function(object, lag_max) {
    .Call(`_bvhar_VARtoVMA`, object, lag_max)
}

#' Build a Linear Transformation Matrix for Vector HAR
#' 
#' @param m integer, dimension
#' @details
#' VHAR is linearly restricted VAR(22) in Y0 = X0 B + Z.
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
scale_har <- function(m) {
    .Call(`_bvhar_scale_har`, m)
}

#' Compute Vector HAR Coefficient Matrices and Fitted Values
#' 
#' @param x X0 processed by \code{\link{build_design}}
#' @param y Y0 processed by \code{\link{build_y0}}
#' @details
#' Given Y0 and Y0, the function estimate least squares
#' Y0 = X1 Phi + Z
#' 
#' @references
#' Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' 
#' Corsi, F. (2008). \emph{A Simple Approximate Long-Memory Model of Realized Volatility}. Journal of Financial Econometrics, 7(2), 174–196. \url{https://doi:10.1093/jjfinec/nbp001}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
estimate_har <- function(x, y) {
    .Call(`_bvhar_estimate_har`, x, y)
}

#' Forecasting BVAR of Minnesota Prior
#' 
#' @param object \code{bvarmn} object by \code{\link{bvar_minnesota}}
#' @param step Integer, Step to forecast
#' @details
#' n-step ahead forecasting using VAR(p) recursively, based on pp35 of Lütkepohl (2007).
#' 
#' @references
#' Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' 
#' Litterman, R. B. (1986). \emph{Forecasting with Bayesian Vector Autoregressions: Five Years of Experience}. Journal of Business & Economic Statistics, 4(1), 25. \url{https://doi:10.2307/1391384}
#' 
#' Bańbura, M., Giannone, D., & Reichlin, L. (2010). \emph{Large Bayesian vector auto regressions}. Journal of Applied Econometrics, 25(1). \url{https://doi:10.1002/jae.1137}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
forecast_bvarmn <- function(object, step) {
    .Call(`_bvhar_forecast_bvarmn`, object, step)
}

#' Forecasting BVAR of Non-hierarchical Matrix Normal Prior
#' 
#' @param object \code{bvarmn} object by \code{\link{bvar_minnesota}}
#' @param step Integer, Step to forecast
#' @details
#' n-step ahead forecasting using VAR(p) recursively, based on pp35 of Lütkepohl (2007).
#' 
#' @references
#' Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' 
#' Ghosh, S., Khare, K., & Michailidis, G. (2018). \emph{High-Dimensional Posterior Consistency in Bayesian Vector Autoregressive Models}. Journal of the American Statistical Association, 114(526). \url{https://doi:10.1080/01621459.2018.1437043}
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
forecast_bvarghosh <- function(object, step) {
    .Call(`_bvhar_forecast_bvarghosh`, object, step)
}

#' Forecasting Bayesian VHAR
#' 
#' @param object \code{bvharmn} object by \code{\link{vhar_lm}}
#' @param step Integer, Step to forecast
#' @details
#' n-step ahead forecasting using VHAR recursively.
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
forecast_bvharmn <- function(object, step) {
    .Call(`_bvhar_forecast_bvharmn`, object, step)
}

#' Forecasting Vector Autoregression
#' 
#' @param object \code{varlse} object by \code{\link{var_lm}}
#' @param step Integer, Step to forecast
#' @details
#' n-step ahead forecasting using VAR(p) recursively, based on pp35 of Lütkepohl (2007).
#' 
#' @references Lütkepohl, H. (2007). \emph{New Introduction to Multiple Time Series Analysis}. Springer Publishing. \url{https://doi.org/10.1007/978-3-540-27752-1}
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
forecast_var <- function(object, step) {
    .Call(`_bvhar_forecast_var`, object, step)
}

#' Forecasting Vector HAR
#' 
#' @param object \code{varlse} object by \code{\link{vhar_lm}}
#' @param step Integer, Step to forecast
#' @details
#' n-step ahead forecasting using VHAR recursively.
#' 
#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
forecast_vhar <- function(object, step) {
    .Call(`_bvhar_forecast_vhar`, object, step)
}

#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
AAt_eigen <- function(x, y) {
    .Call(`_bvhar_AAt_eigen`, x, y)
}

#' @useDynLib bvhar
#' @importFrom Rcpp sourceCpp
#' @export
kroneckerprod <- function(x, y) {
    .Call(`_bvhar_kroneckerprod`, x, y)
}

