#' Density Plot for Minnesota Prior VAR Model
#' 
#' This function draws density plot for coefficient matrices of Minnesota prior VAR model.
#' 
#' @param object `summary.normaliw` object
#' @param type Plot mean or variance. `"coef"` indicates VAR coefficients and `"variance"` for diagonal elements for Sigma (By default, coefficients).
#' @param var_name Variable name (for coefficients)
#' @param true_est `r lifecycle::badge("experimental")` True estimates to draw
#' @param NROW Numer of facet row
#' @param NCOL Numer of facet col
#' @param ... not used
#' 
#' @importFrom ggplot2 ggplot aes geom_density geom_vline geom_point facet_wrap labs element_text element_blank
#' @importFrom dplyr filter mutate
#' @importFrom tidyr pivot_longer
#' @importFrom tibble rownames_to_column
#' @export
autoplot.summary.normaliw <- function(object, 
                                      type = c("coef", "variance"), 
                                      var_name, 
                                      true_est = NULL,
                                      NROW = NULL, 
                                      NCOL = NULL, ...) {
  type <- match.arg(type)
  switch(
    type,
    "coef" = {
      X <- object$coefficients
      if (missing(var_name)) {
        stop("Provide 'var_name'")
      }
      X <- 
        lapply(
          1:(object$N),
          function(x) {
            X[,, x] %>% 
              as.data.frame() %>% 
              rownames_to_column(var = "lags")
          }
        ) %>% 
        bind_rows() %>% 
        pivot_longer(-lags, names_to = "name", values_to = "value") %>% 
        filter(name == var_name) %>% 
        mutate(coef_hat = rep(object$mn_mean[,var_name], object$N))
    },
    "variance" = {
      X <- object$covmat
      X <- 
        lapply(
          1:(object$N),
          function(x) {
            X[,, x] %>% 
              diag()
          }
        ) %>% 
        bind_rows() %>% 
        mutate(id = 1:(object$N)) %>% 
        pivot_longer(-id, names_to = "lags", values_to = "value")
    }
  )
  if (!is.null(true_est)) {
    X <- 
      X %>% 
      mutate(true_est = rep(true_est, object$N))
  }
  p <- 
    X %>% 
    ggplot(aes(x = value)) +
    geom_density() +
    facet_wrap(
      lags ~ .,
      nrow = NROW,
      ncol = NCOL,
      scales = "free"
    ) +
    labs(
      x = element_blank(),
      y = element_blank()
    )
  if (type == "coef") {
    p <- 
      p +
      geom_vline(aes(xintercept = coef_hat), col = "blue", alpha = .5)
  }
  # draw given coefficient estimates------------------------
  if (!is.null(true_est)) {
    p +
      geom_vline(aes(xintercept = true_est), col = "red", alpha = .5)
  } else {
    p
  }
}

#' Residual Plot for Minnesota Prior VAR Model
#' 
#' This function draww residual plot for covariance matrix of Minnesota prior VAR model.
#' 
#' @param object `normaliw` object
#' @param hcol color of horizontal line = 0 (By default, grey)
#' @param hsize size of horizontal line = 0 (By default, 1.5)
#' @param ... additional options for geom_point
#' 
#' @importFrom ggplot2 ggplot aes geom_point geom_hline facet_grid labs element_text element_blank
#' @importFrom tidyr pivot_longer
#' @export
autoplot.normaliw <- function(object, hcol = "grey", hsize = 1.5, ...) {
  X <- object$residuals %>% as.data.frame()
  X[["id"]] <- 1:object$obs
  X <- 
    X %>% 
    pivot_longer(-id, names_to = "name", values_to = "value")
  X %>% 
    ggplot(aes(x = id, y = value)) +
    geom_hline(yintercept = 0, col = hcol, size = hsize) +
    geom_point(...) +
    facet_grid(
      name ~ .,
      scales = "free_y"
    ) +
    labs(
      x = element_blank(),
      y = element_blank()
    )
}

#' Make Data Form to Make Forecasting Plot
#' 
#' @param object `predbvhar` object usually generated by [stats::predict()] function in this package
#' 
#' @importFrom dplyr bind_rows mutate n left_join
#' @importFrom purrr reduce
#' @importFrom tidyr pivot_longer
#' @noRd
gather_predbvhar <- function(object) {
  Y <- 
    object$y %>% 
    as.data.frame() %>% 
    mutate(forecast = FALSE)
  PRED <- 
    object$forecast %>% 
    as.data.frame() %>% 
    mutate(forecast = TRUE)
  lapply(
    c("forecast", "lower_joint", "upper_joint"),
    function(comp) {
      PRED <- 
        object[[comp]] %>% 
        as.data.frame() %>% 
        mutate(forecast = TRUE)
      Y %>% 
        bind_rows(PRED) %>% 
        mutate(id = 1:n()) %>% 
        pivot_longer(-c(id, forecast), names_to = "variable", values_to = paste("value", comp, sep = "_"))
    }
  ) %>% 
    reduce(left_join, by = c("id", "variable", "forecast")) %>% 
    mutate(Model = object$process)
}

#' Forecasting Lines and Region
#' 
#' This function draws h-step ahead forecasts their confidence (credible) region.
#' 
#' @param mapping Set of aesthetic mappings created by [ggplot2::aes()] or [ggplot2::aes_()].
#' If specified and `inherit.aes = TRUE` (the default), it is combined with the default mapping at the top level of the plot.
#' You must supply mapping if there is no plot mapping.
#' @param data The data to be displayed in this layer.
#' This should be generated by interal function, `gather_predbvhar`.
#' @param stat The statistical transformation to use on the data for this layer, as a string.
#' @param position Position adjustment, either as a string, or the result of a call to a position adjustment function.
#' @param alpha_scale Scale of transparency parameter (`alpha`) between the two layers. `alpha` of CI ribbon = `alpha_scale` * `alpha` of path (By default, .3)
#' @param ci_param Parameter lists for [ggplot2::geom_ribbon()]. See details.
#' @param line_param Parameter lists for [ggplot2::geom_path()].
#' @param inherit.aes If \code{FALSE}, overrides the default aesthetics, rather than combining with them.
#' This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification,
#' e.g. [ggplot2::borders()].
#' @details 
#' * `alpha_scale` is recommended to be smaller than 1.
#' * In case of `ci_param`, since it is controlling CI, try to specify `alpha` and `colour`.
#' 
#' `gather_predbvhar` produces a `tibble` with columns named
#' 
#' \itemize{
#'   \item `forecast` - If the row is observed one or forecasted one
#'   \item `id` - Index of the row
#'   \item `variable` - Name of the variable
#'   \item `value_forecast` - Point forecasts
#'   \item `value_lower_joint` - Lower CI
#'   \item `value_upper_joint` - Upper CI
#'   \item `model` - Fitting Model
#' }
#' 
#' @importFrom ggplot2 aes layer
#' @noRd
geom_predbvhar <- function(mapping = NULL, 
                           data = NULL, 
                           stat = "identity", 
                           position = "identity", 
                           alpha_scale = .3,
                           ci_param = list(),
                           line_param = list(),
                           inherit.aes = TRUE) {
  line_param$alpha <- ifelse(is.null(line_param$alpha), 1, line_param$alpha)
  ci_param$alpha <- line_param$alpha * alpha_scale
  ci_layer <- layer(
    geom = "ribbon",
    stat = "identity",
    data = data,
    mapping = aes(
      ymin = value_lower_joint, 
      ymax = value_upper_joint, 
      fill = Model
    ),
    position = position,
    params = ci_param,
    inherit.aes = inherit.aes
  )
  line_layer <- layer(
    geom = "path",
    stat = "identity",
    data = data,
    mapping = aes(colour = Model),
    position = position,
    params = line_param,
    inherit.aes = inherit.aes,
    show.legend = FALSE
  )
  list(ci_layer, line_layer)
}

#' Plot Forecast Result
#' 
#' Plots the forecasting result with forecast regions.
#' 
#' @param object `predbvhar` object
#' @param type Divide variables using [ggplot2::facet_grid()] ("grid": default) or [ggplot2::facet_wrap()] ("wrap")
#' @param ci_fill color of CI
#' @param ci_alpha Transparency of CI
#' @param alpha_scale Scale of transparency parameter (`alpha`) between the two layers. `alpha` of CI ribbon = `alpha_scale` * `alpha` of path (By default, .5)
#' @param x_cut plot x axes from \code{x_cut} for visibility
#' @param viridis If `TRUE`, scale CI and forecast line using [ggplot2::scale_fill_viridis_d()] and [ggplot2::scale_colour_viridis_d], respectively.
#' @param viridis_option Option for viridis string. See `option` of [ggplot2::scale_colour_viridis_d]. Choose one of `c("A", "B", "C", "D", "E")`. By default, `"D"`.
#' @param NROW `nrow` of [ggplot2::facet_wrap()]
#' @param NCOL `ncol` of [ggplot2::facet_wrap()]
#' @param ... additional option for [ggplot2::geom_path()]
#' 
#' @importFrom ggplot2 ggplot aes facet_grid geom_path labs element_blank scale_fill_viridis_d scale_colour_viridis_d
#' @importFrom dplyr filter
#' @export
autoplot.predbvhar <- function(object, 
                               type = c("grid", "wrap"), 
                               ci_alpha = .7,
                               alpha_scale = .3,
                               x_cut = 1,
                               viridis = FALSE,
                               viridis_option = "D",
                               NROW = NULL, 
                               NCOL = NULL, ...) {
  type <- match.arg(type)
  forecast_list <- 
    gather_predbvhar(object) %>% 
    filter(id >= x_cut)
  p <- 
    forecast_list %>% 
    ggplot(aes(x = id, y = value_forecast)) +
    geom_path(data = forecast_list %>% filter(forecast == FALSE))
  p <- 
    switch(
      type,
      "grid" = {
        p +
          geom_predbvhar(
            data = forecast_list %>% filter(forecast == TRUE),
            alpha_scale = alpha_scale,
            ci_param = list(alpha = ci_alpha, colour = NA),
            line_param = list(...)
          ) +
          facet_grid(variable ~ ., scales = "free_y") +
          labs(
            x = element_blank(),
            y = element_blank()
          )
      },
      "wrap" = {
        p +
          geom_predbvhar(
            data = forecast_list %>% filter(forecast == TRUE),
            alpha_scale = alpha_scale,
            ci_param = list(alpha = ci_alpha, colour = NA),
            line_param = list(...)
          ) +
          facet_wrap(variable ~ ., nrow = NROW, ncol = NCOL, scales = "free_y") +
          labs(
            x = element_blank(),
            y = element_blank()
          )
      }
    )
  # viridis----------------------------------
  if (viridis) {
    p +
      scale_fill_viridis_d(option = viridis_option) +
      scale_colour_viridis_d(option = viridis_option)
  } else {
    p
  }
}

#' @rdname autoplot.predbvhar
#' 
#' @importFrom dplyr bind_rows mutate filter
#' @importFrom ggplot2 ggplot aes facet_grid labs element_blank last_plot ggplot_build geom_path
#' @export
autolayer.predbvhar <- function(object, 
                                ci_fill = "grey70", 
                                ci_alpha = .5,
                                alpha_scale = .3, ...) {
  aes_data <- 
    last_plot() %>% 
    ggplot_build() %>% 
    .$plot %>% 
    .$data # same form as forecast_list above
  x_cut <- aes_data[["id"]][1]
  NEW_list <- 
    gather_predbvhar(object) %>% # new forecast_list
    filter(id >= x_cut)
  geom_predbvhar(
    data = NEW_list %>% filter(forecast == TRUE),
    alpha_scale = alpha_scale,
    ci_param = list(alpha = ci_alpha, colour = NA),
    line_param = list(...)
  )
}

#' Adding Test Data Layer
#' 
#' This function adds a layer of test dataset.
#' 
#' @param data Test data to draw.
#' @param colour Colour of the line (By default, `"red"`).
#' @param num_train `r lifecycle::badge("experimental")` Size of the train data.
#' @param ... Other arguments passed on the [ggplot2::geom_path()].
#' 
#' @importFrom ggplot2 aes geom_path
#' @importFrom dplyr mutate n
#' @importFrom tidyr pivot_longer
#' @export
geom_eval <- function(data, colour = "red", num_train = 1, ...) {
  if (is.matrix(data)) {
    data <- as.data.frame(data)
  }
  if (!is.data.frame(data)) {
    stop("'data' should be a data frame or matrix.")
  }
  if (!all(apply(data, 2, is.numeric))) {
    stop("Every column must be numeric class.")
  }
  new_data <- 
    data %>% 
    mutate(id = 1:n() + num_train) %>% 
    pivot_longer(-id, names_to = "variable", values_to = "value")
  geom_path(
    aes(x = id, y = value),
    data = new_data,
    colour = colour,
    ...
  )
}

#' Make Data Form to Make Loss Plot
#' 
#' @param object List of `predbvhar`.
#' @param y_test Test data to be compared. should be the same format with the train data and predict$forecast.
#' @param loss Loss function to be used (`"mse"`: MSE, `"mae"`: MAE, `mape`: MAPE, `"mase"`: MASE)
#' 
#' @importFrom dplyr mutate bind_rows
#' @importFrom tidyr pivot_longer
#' @noRd
gather_loss <- function(object, y_test, loss = c("mse", "mae", "mape", "mase")) {
  loss <- match.arg(loss)
  if (missing(y_test)) {
    stop("Provide 'y_test' data")
  }
  # Must be list(predbvhar)-------------
  if (is.predbvhar(object)) {
    object <- list(object)
  }
  if (!all(sapply(object, is.predbvhar)) && !all(sapply(object, is.bvharcv))) {
    stop("'object' should be the list of 'predbvhar' or 'bvharcv'")
  }
  # Model names-------------------------
  mod_name <- 
    object %>% 
    lapply(function(PRED) PRED$process) %>% 
    unlist()
  # error for each model----------------
  score_dt <- 
    switch(
      loss,
      "mse" = {
        object %>% 
          lapply(mse, y_test)
      },
      "mae" = {
        object %>% 
          lapply(mae, y_test)
      },
      "mape" = {
        object %>% 
          lapply(mape, y_test)
      },
      "mase" = {
        object %>% 
          lapply(mase, y_test)
      }
    )
  score_dt %>% 
    bind_rows() %>% 
    mutate(Model = mod_name) %>% 
    pivot_longer(-Model, names_to = "name", values_to = "score")
}

#' Compute Average Loss to Draw Horizontal Line
#' 
#' @param data Result made by `gather_loss`
#' 
#' @importFrom dplyr group_by mutate
#' @noRd
summarise_loss <- function(data) {
  data %>% 
    group_by(Model) %>% 
    mutate(average = mean(score))
}

#' Loss Lines
#' 
#' This function adds a layer of Loss given `predbvhar`.
#' 
#' @param mapping Set of aesthetic mappings created by [ggplot2::aes()] or [ggplot2::aes_()].
#' @param data The data to be displayed in this layer.
#' `predbvhar` object or list of `predbvhar`.
#' @param y_test Test data to be compared. should be the same format with the train data and predict$forecast.
#' @param loss Loss function to be used (`"mse"`: MSE, `"mae"`: MAE, `mape`: MAPE, `"mase"`: MASE)
#' @param mean_line Whether to draw average loss. By default, `FALSE`.
#' @param line_param Parameter lists for [ggplot2::geom_path()].
#' @param mean_param Parameter lists for average loss with [ggplot2::geom_hline()].
#' @param inherit.aes If \code{FALSE}, overrides the default aesthetics, rather than combining with them.
#' This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification,
#' e.g. [ggplot2::borders()].
#' @param show.legend `logical`. Should this layer be included in the legend?
#' `NA`, the default, includes if any aesthetics are mapped.
#' `FALSE` never includes, and `TRUE` always includes.
#' It can also be a named logical vector to finely select the aesthetics to display.
#' @details 
#' Internal `gather_loss` function produces a `tibble` with columns named
#' 
#' \itemize{
#'   \item `Model` - The name of the model from `predbvhar$process`
#'   \item `name` - The variable name
#'   \item `score` - Values of losses
#' }
#'
#' Additionally, `summarise_loss` function adds grouped average of `score` by `Model` named `average`.
#' 
#' @seealso 
#' * [mse()] to compute MSE for given forecast result
#' * [mae()] to compute MAE for given forecast result
#' * [mape()] to compute MAPE for given forecast result
#' * [mase()] to compute MASE for given forecast result
#' 
#' @importFrom ggplot2 aes layer
#' @importFrom dplyr mutate bind_rows
#' @importFrom tidyr pivot_longer
#' @noRd
geom_loss <- function(mapping = NULL, 
                      data = NULL, 
                      y_test,
                      loss = c("mse", "mae", "mape", "mase"),
                      mean_line = FALSE,
                      line_param = list(),
                      mean_param = list(),
                      inherit.aes = TRUE,
                      show.legend = NA, ...) {
  score_dt <- gather_loss(data, y_test, loss)
  loss_layer <- layer(
    geom = "line",
    stat = "identity",
    data = score_dt,
    mapping = aes(
      x = name,
      y = score,
      colour = Model,
      group = Model
    ),
    position = "identity",
    params = line_param,
    inherit.aes = inherit.aes,
    show.legend = show.legend
  )
  if (mean_line) {
    mean_dt <- summarise_loss(score_dt)
    mean_layer <- layer(
      geom = "hline",
      stat = "identity",
      data = mean_dt,
      mapping = aes(
        yintercept = average,
        colour = Model
      ),
      position = "identity",
      params = mean_param,
      inherit.aes = inherit.aes,
      show.legend = show.legend
    )
    list(mean_layer, loss_layer)
  } else {
    loss_layer
  }
}

#' Compare Lists of Models
#' 
#' Draw plot of test error for given models
#' 
#' @param mod_list Lists of forecast results (`predbvhar` objects)
#' @param y Test data to be compared. should be the same format with the train data and predict$forecast.
#' @param type Loss function to be used (`"mse"`: MSE, `"mae"`: MAE, `mape`: MAPE, `"mase"`: MASE)
#' @param mean_line Whether to draw average loss. By default, `FALSE`.
#' @param line_param Parameter lists for [ggplot2::geom_path()].
#' @param mean_param Parameter lists for average loss with [ggplot2::geom_hline()].
#' @param viridis If `TRUE`, scale CI and forecast line using [ggplot2::scale_fill_viridis_d()] and [ggplot2::scale_colour_viridis_d], respectively.
#' @param viridis_option Option for viridis string. See `option` of [ggplot2::scale_colour_viridis_d]. Choose one of `c("A", "B", "C", "D", "E")`. By default, `"D"`.
#' @param ... Additional options for `geom_loss` (`inherit.aes` and `show.legend`)
#' 
#' @seealso 
#' * [mse()] to compute MSE for given forecast result
#' * [mae()] to compute MAE for given forecast result
#' * [mape()] to compute MAPE for given forecast result
#' * [mase()] to compute MASE for given forecast result
#' 
#' @importFrom ggplot2 labs element_blank scale_colour_viridis_d
#' @export
plot_loss <- function(mod_list, 
                      y, 
                      type = c("mse", "mae", "mape", "mase"), 
                      mean_line = FALSE,
                      line_param = list(),
                      mean_param = list(),
                      viridis = FALSE, 
                      viridis_option = "D", ...) {
  # plot------------------------------------
  p <- 
    ggplot() +
    geom_loss(
      data = mod_list,
      y_test = y,
      loss = type,
      mean_line = mean_line,
      line_param = line_param,
      mean_param = mean_param,
      ...
    ) +
    labs(
      x = element_blank(),
      y = element_blank()
    )
  # viridis----------------------------------
  if (viridis) {
    p +
      scale_colour_viridis_d(option = viridis_option)
  } else {
    p
  }
}
