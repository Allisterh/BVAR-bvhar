#' Split a Time Series Dataset into Train-Test Set
#' 
#' Split a given time series dataset into train and test set for evaluation.
#' 
#' @param y Time series data of which columns indicate the variables
#' @param n.ahead step to evaluate
#' 
#' @seealso 
#' \code{\link[rsample:initial_time_split]{rsample::initial_time_split}}, \code{\link[rsample:training]{rsample::training}}, and \code{\link[rsample:testing]{rsample::testing}} process
#' provides tidyverse solution.
#' 
#' @importFrom stats setNames
#' @export
divide_ts <- function(y, n.ahead) {
  num_ts <- nrow(y)
  fac_train <- rep(1, num_ts - n.ahead)
  fac_test <- rep(2, n.ahead)
  y %>% 
    split.data.frame(
      factor(c(fac_train, fac_test))
    ) %>% 
    setNames(c("train", "test"))
}

#' Make Data Form to Make Forecasting Plot
#' 
#' @param object \code{predbvhar} object usually generated by \code{predict()} function in this package
#' 
#' @importFrom dplyr bind_rows mutate n left_join
#' @importFrom purrr reduce
#' @importFrom tidyr pivot_longer
#' @noRd
gather_predbvhar <- function(object) {
  Y <- 
    object$y %>% 
    as.data.frame() %>% 
    mutate(forecast = FALSE)
  PRED <- 
    object$forecast %>% 
    as.data.frame() %>% 
    mutate(forecast = TRUE)
  lapply(
    c("forecast", "lower_joint", "upper_joint"),
    function(comp) {
      PRED <- 
        object[[comp]] %>% 
        as.data.frame() %>% 
        mutate(forecast = TRUE)
      Y %>% 
        bind_rows(PRED) %>% 
        mutate(id = 1:n()) %>% 
        pivot_longer(-c(id, forecast), names_to = "variable", values_to = paste("value", comp, sep = "_"))
    }
  ) %>% 
    reduce(left_join, by = c("id", "variable", "forecast")) %>% 
    mutate(model = object$process)
}

#' Plot Forecast Result
#' 
#' Plots the forecasting result with forecast regions.
#' 
#' @param object \code{predbvhar} object usually generated by \code{predict()} function in this package
#' @param type Divide variables using \code{\link[ggplot2:facet_grid]{ggplot2::facet_grid}} ("grid": default) or \code{\link[ggplot2:facet_wrap]{ggplot2::facet_wrap}} ("wrap")
#' @param ci_fill color of CI
#' @param ci_alpha Transparency of CI
#' @param x_cut plot x axes from \code{x_cut} for visibility
#' @param line_type linetype regarding to forecasting. See \code{\link[ggplot2:scale_linetype_manual]{ggplot2::scale_linetype_manual}}
#' @param label_nudge \code{nudge_x} and \code{nudge_y} for \code{\link[ggplot2:geom_label]{ggplot2::geom_label}}
#' @param label_size \code{label_size} for \code{\link[ggplot2:geom_label]{ggplot2::geom_label}}
#' @param label_alpha Transparency of \code{\link[ggplot2:geom_label]{ggplot2::geom_label}}
#' @param NROW \code{nrow} of \code{\link[ggplot2:facet_wrap]{ggplot2::facet_wrap}}
#' @param NCOL \code{ncol} of \code{\link[ggplot2:facet_wrap]{ggplot2::facet_wrap}}
#' @param ... additional option for \code{\link[ggplot2:geom_path]{ggplot2::geom_path}}
#' 
#' @importFrom ggplot2 ggplot aes geom_path geom_ribbon facet_grid scale_linetype_manual labs element_blank
#' @importFrom ggrepel geom_label_repel
#' @importFrom dplyr filter
#' @export
autoplot.predbvhar <- function(object, 
                               type = c("grid", "wrap"), 
                               ci_fill = "grey70", 
                               ci_alpha = 1,
                               x_cut = 1, 
                               line_type = c("FALSE" = "dotted", "TRUE" = "solid"), 
                               label_nudge = c(0, 0),
                               label_size = .25,
                               label_alpha = .7,
                               NROW = NULL, 
                               NCOL = NULL, ...) {
  type <- match.arg(type)
  forecast_list <- gather_predbvhar(object)
  p <- 
    forecast_list %>% 
    filter(id >= x_cut) %>% 
    mutate(
      x_label = ifelse(id == max(id[forecast == FALSE]), id, NA), 
      y_label = ifelse(id == max(id[forecast == FALSE]), value_forecast, NA)
    ) %>% 
    ggplot(aes(x = id, y = value_forecast, colour = model))
  switch(
    type,
    "grid" = {
      p +
        geom_predbvhar(
          ci_param = list(fill = ci_fill, alpha = ci_alpha, colour = NA),
          line_param = list(...),
          label_param = list(na.rm = TRUE, nudge_x = label_nudge[1], nudge_y = label_nudge[2], label.size = label_size, alpha = label_alpha)
        ) +
        scale_linetype_manual(values = line_type) +
        facet_grid(variable ~ ., scales = "free_y") +
        labs(
          x = element_blank(),
          y = element_blank()
        )
    },
    "wrap" = {
      p +
        geom_predbvhar(
          ci_param = list(fill = ci_fill, alpha = ci_alpha, colour = NA),
          line_param = list(...),
          label_param = list(na.rm = TRUE, nudge_x = label_nudge[1], nudge_y = label_nudge[2], label.size = label_size, alpha = label_alpha)
        ) +
        scale_linetype_manual(values = line_type) +
        facet_wrap(variable ~ ., nrow = NROW, ncol = NCOL, scales = "free_y") +
        labs(
          x = element_blank(),
          y = element_blank()
        )
    }
  )
}

#' @rdname autoplot.predbvhar
#' 
#' @importFrom dplyr bind_rows mutate filter
#' @importFrom ggplot2 ggplot aes geom_path geom_ribbon facet_grid scale_linetype_manual labs element_blank last_plot ggplot_build
#' @importFrom ggrepel geom_label_repel
#' @export
autolayer.predbvhar <- function(object, 
                                ci_fill = "grey70", 
                                ci_alpha = 1,
                                line_type = c("FALSE" = "dotted", "TRUE" = "solid"),
                                label_nudge = c(0, 0),
                                label_size = .25,
                                label_alpha = .7,...) {
  aes_data <- 
    last_plot() %>% 
    ggplot_build() %>% 
    .$plot %>% 
    .$data # same form as forecast_list above
  x_cut <- aes_data[["id"]][1]
  NEW_list <- 
    gather_predbvhar(object) %>% # new forecast_list
    filter(id >= x_cut) %>% 
    mutate(
      x_label = ifelse(id == max(id), id, NA), 
      y_label = ifelse(id == max(id), value_forecast, NA)
    )
  geom_predbvhar(
    data = NEW_list,
    ci_param = list(fill = ci_fill, alpha = ci_alpha, colour = NA),
    line_param = list(...),
    label_param = list(na.rm = TRUE, nudge_x = label_nudge[1], nudge_y = label_nudge[2], label.size = label_size, alpha = label_alpha)
  )
}

#' Evaluate the Model Based on MSPE (Mean Squared Prediction Error)
#' @param x \code{predbvhar} object
#' @param y test data to be compared
#' @param ... not used
#' 
#' @export
mse <- function(x, y, ...) {
  UseMethod("mse", x)
}

#' Compute MSE
#' 
#' @param x \code{predbvhar} object
#' @param y test data to be compared. should be the same format with the train data and predict$forecast.
#' @param ... not used
#' 
#' @export
mse.predbvhar <- function(x, y, ...) {
  apply(y - x$forecast, 2, function(x) mean(x^2))
}

#' Evaluate the Model Based on MAPE (Mean Absolute Percentage Error)
#' @param x \code{predbvhar} object
#' @param y test data to be compared
#' @param ... not used
#' 
#' @export
mape <- function(x, y, ...) {
  UseMethod("mape", x)
}

#' Compute MAPE
#' 
#' @param x \code{predbvhar} object
#' @param y test data to be compared. should be the same format with the train data and predict$forecast.
#' @param ... not used
#' 
#' @export
mape.predbvhar <- function(x, y, ...) {
  apply((y - x$forecast) / y, 2, function(x) mean(abs(x)))
}

#' Compare Lists of Models
#' 
#' Draw plot of test error for given models
#' 
#' @param mod_list lists of forecast results (\code{predbvhar} objects)
#' @param y test data to be compared. should be the same format with the train data and predict$forecast.
#' @param type loss function to be used (\code{"mse"}: MSE, \code{mape}: MAPE)
#' @param ... additional options for \code{\link[ggplot2:geom_line]{ggplot2::geom_line}}
#' 
#' @importFrom dplyr mutate bind_rows
#' @importFrom tidyr pivot_longer
#' @importFrom ggplot2 ggplot aes geom_line labs element_blank
#' @export
plot_loss <- function(mod_list, y, type = c("mse", "mape"), ...) {
  type <- match.arg(type)
  mod_names <- 
    mod_list %>% 
    lapply(function(PRED) PRED$process) %>% 
    unlist()
  SCORE <- 
    switch(
      type,
      "mse" = {
        mod_list %>% 
          lapply(mse, y = y)
      },
      "mape" = {
        mod_list %>% 
          lapply(mape, y = y)
      }
    )
  SCORE %>% 
    bind_rows() %>% 
    mutate(Model = mod_names) %>% 
    pivot_longer(-Model, names_to = "name", values_to = "score") %>% 
    ggplot(aes(x = name, y = score, colour = Model)) +
    geom_line(aes(group = Model), ...) +
    labs(
      x = element_blank(),
      y = element_blank()
    )
}
