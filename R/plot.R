#' Density Plot for Minnesota Prior VAR Model
#' 
#' This function draws density plot for coefficient matrices of Minnesota prior VAR model.
#' 
#' @param object `summary.bvarmn` object
#' @param type Plot mean or variance. `"coef"` indicates VAR coefficients and `"variance"` for diagonal elements for Sigma (By default, coefficients).
#' @param var_name variable name (for coefficients)
#' @param NROW Numer of facet row
#' @param NCOL Numer of facet col
#' @param ... not used
#' 
#' @importFrom ggplot2 ggplot aes geom_density geom_point facet_wrap labs element_text element_blank
#' @importFrom dplyr filter
#' @importFrom tidyr pivot_longer
#' @importFrom tibble rownames_to_column
#' @export
autoplot.summary.bvarmn <- function(object, type = c("coef", "variance"), var_name = NULL, NROW = NULL, NCOL = NULL, ...) {
  type <- match.arg(type)
  switch(
    type,
    "coef" = {
      X <- object$coefficients
      if (is.null(var_name)) stop("Provide 'var_name'")
      X <- 
        lapply(
          1:(object$N),
          function(x) {
            X[,, x] %>% 
              as.data.frame() %>% 
              rownames_to_column(var = "lags")
          }
        ) %>% 
        bind_rows() %>% 
        pivot_longer(-lags, names_to = "name", values_to = "value") %>% 
        filter(name == var_name)
    },
    "variance" = {
      X <- object$covmat
      X <- 
        lapply(
          1:(object$N),
          function(x) {
            X[,, x] %>% 
              diag()
          }
        ) %>% 
        bind_rows() %>% 
        mutate(id = 1:(object$N)) %>% 
        pivot_longer(-id, names_to = "lags", values_to = "value")
    }
  )
  X %>% 
    ggplot(aes(x = value)) +
    geom_density() +
    facet_wrap(
      lags ~ .,
      nrow = NROW,
      ncol = NCOL,
      scales = "free"
    ) +
    labs(
      x = element_blank(),
      y = element_blank()
    )
}

#' Residual Plot for Minnesota Prior VAR Model
#' 
#' This function draww residual plot for covariance matrix of Minnesota prior VAR model.
#' 
#' @param object `bvarmn` object
#' @param hcol color of horizontal line = 0 (By default, grey)
#' @param hsize size of horizontal line = 0 (By default, 1.5)
#' @param ... additional options for geom_point
#' 
#' @importFrom ggplot2 ggplot aes geom_point geom_hline facet_grid labs element_text element_blank
#' @importFrom tidyr pivot_longer
#' @export
autoplot.bvarmn <- function(object, hcol = "grey", hsize = 1.5, ...) {
  X <- object$residuals %>% as.data.frame()
  X[["id"]] <- 1:object$obs
  X <- 
    X %>% 
    pivot_longer(-id, names_to = "name", values_to = "value")
  X %>% 
    ggplot(aes(x = id, y = value)) +
    geom_hline(yintercept = 0, col = hcol, size = hsize) +
    geom_point(...) +
    facet_grid(
      name ~ .,
      scales = "free_y"
    ) +
    labs(
      x = element_blank(),
      y = element_blank()
    )
}

#' Make Data Form to Make Forecasting Plot
#' 
#' @param object `predbvhar` object usually generated by [stats::predict()] function in this package
#' 
#' @importFrom dplyr bind_rows mutate n left_join
#' @importFrom purrr reduce
#' @importFrom tidyr pivot_longer
#' @noRd
gather_predbvhar <- function(object) {
  Y <- 
    object$y %>% 
    as.data.frame() %>% 
    mutate(forecast = FALSE)
  PRED <- 
    object$forecast %>% 
    as.data.frame() %>% 
    mutate(forecast = TRUE)
  lapply(
    c("forecast", "lower_joint", "upper_joint"),
    function(comp) {
      PRED <- 
        object[[comp]] %>% 
        as.data.frame() %>% 
        mutate(forecast = TRUE)
      Y %>% 
        bind_rows(PRED) %>% 
        mutate(id = 1:n()) %>% 
        pivot_longer(-c(id, forecast), names_to = "variable", values_to = paste("value", comp, sep = "_"))
    }
  ) %>% 
    reduce(left_join, by = c("id", "variable", "forecast")) %>% 
    mutate(Model = object$process)
}

#' Forecasting Lines and Region
#' 
#' This function draws h-step ahead forecasts their confidence (credible) region.
#' 
#' @param mapping Set of aesthetic mappings created by [ggplot2::aes()] or [ggplot2::aes_()].
#' If specified and `inherit.aes = TRUE` (the default), it is combined with the default mapping at the top level of the plot.
#' You must supply mapping if there is no plot mapping.
#' @param data The data to be displayed in this layer.
#' This should be generated by interal function, `gather_predbvhar`.
#' @param stat The statistical transformation to use on the data for this layer, as a string.
#' @param position Position adjustment, either as a string, or the result of a call to a position adjustment function.
#' @param alpha_scale Scale of transparency parameter (`alpha`) between the two layers. `alpha` of CI ribbon = `alpha_scale` * `alpha` of path (By default, .3)
#' @param ci_param Parameter lists for [ggplot2::geom_ribbon()]. See details.
#' @param line_param Parameter lists for [ggplot2::geom_path()].
#' @param inherit.aes If \code{FALSE}, overrides the default aesthetics, rather than combining with them.
#' This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification,
#' e.g. [ggplot2::borders()].
#' @details 
#' * `alpha_scale` is recommended to be smaller than 1.
#' * In case of `ci_param`, since it is controlling CI, try to specify `alpha` and `colour`.
#' 
#' `gather_predbvhar` produces a `tibble` with columns named
#' 
#' \itemize{
#'   \item `forecast` - If the row is observed one or forecasted one
#'   \item `id` - Index of the row
#'   \item `variable` - Name of the variable
#'   \item `value_forecast` - Point forecasts
#'   \item `value_lower_joint` - Lower CI
#'   \item `value_upper_joint` - Upper CI
#'   \item `model` - Fitting Model
#' }
#' 
#' @importFrom ggplot2 aes layer
#' @export
geom_predbvhar <- function(mapping = NULL, 
                           data = NULL, 
                           stat = "identity", 
                           position = "identity", 
                           alpha_scale = .3,
                           ci_param = list(),
                           line_param = list(),
                           inherit.aes = TRUE) {
  line_param$alpha <- ifelse(is.null(line_param$alpha), 1, line_param$alpha)
  ci_param$alpha <- line_param$alpha * alpha_scale
  ci_layer <- layer(
    geom = "ribbon",
    stat = "identity",
    data = data,
    mapping = aes(
      ymin = value_lower_joint, 
      ymax = value_upper_joint, 
      fill = Model
    ),
    position = position,
    params = ci_param,
    inherit.aes = inherit.aes
  )
  line_layer <- layer(
    geom = "path",
    stat = "identity",
    data = data,
    mapping = aes(colour = Model),
    position = position,
    params = line_param,
    inherit.aes = inherit.aes,
    show.legend = FALSE
  )
  list(ci_layer, line_layer)
}

#' Plot Forecast Result
#' 
#' Plots the forecasting result with forecast regions.
#' 
#' @param object `predbvhar` object
#' @param type Divide variables using [ggplot2::facet_grid()] ("grid": default) or [ggplot2::facet_wrap()] ("wrap")
#' @param ci_fill color of CI
#' @param ci_alpha Transparency of CI
#' @param alpha_scale Scale of transparency parameter (`alpha`) between the two layers. `alpha` of CI ribbon = `alpha_scale` * `alpha` of path (By default, .5)
#' @param x_cut plot x axes from \code{x_cut} for visibility
#' @param viridis If `TRUE`, scale CI and forecast line using [ggplot2::scale_fill_viridis_d()] and [ggplot2::scale_colour_viridis_d], respectively.
#' @param viridis_option Option for viridis string. See `option` of [ggplot2::scale_colour_viridis_d]. Choose one of `c("A", "B", "C", "D", "E")`. By default, `"D"`.
#' @param NROW `nrow` of [ggplot2::facet_wrap()]
#' @param NCOL `ncol` of [ggplot2::facet_wrap()]
#' @param ... additional option for [ggplot2::geom_path()]
#' 
#' @importFrom ggplot2 ggplot aes facet_grid geom_path labs element_blank scale_fill_viridis_d scale_colour_viridis_d
#' @importFrom dplyr filter
#' @export
autoplot.predbvhar <- function(object, 
                               type = c("grid", "wrap"), 
                               ci_alpha = .7,
                               alpha_scale = .3,
                               x_cut = 1,
                               viridis = FALSE,
                               viridis_option = "D",
                               NROW = NULL, 
                               NCOL = NULL, ...) {
  type <- match.arg(type)
  forecast_list <- 
    gather_predbvhar(object) %>% 
    filter(id >= x_cut)
  p <- 
    forecast_list %>% 
    ggplot(aes(x = id, y = value_forecast)) +
    geom_path(data = forecast_list %>% filter(forecast == FALSE))
  p <- 
    switch(
      type,
      "grid" = {
        p +
          geom_predbvhar(
            data = forecast_list %>% filter(forecast == TRUE),
            alpha_scale = alpha_scale,
            ci_param = list(alpha = ci_alpha, colour = NA),
            line_param = list(...)
          ) +
          facet_grid(variable ~ ., scales = "free_y") +
          labs(
            x = element_blank(),
            y = element_blank()
          )
      },
      "wrap" = {
        p +
          geom_predbvhar(
            data = forecast_list %>% filter(forecast == TRUE),
            alpha_scale = alpha_scale,
            ci_param = list(alpha = ci_alpha, colour = NA),
            line_param = list(...)
          ) +
          facet_wrap(variable ~ ., nrow = NROW, ncol = NCOL, scales = "free_y") +
          labs(
            x = element_blank(),
            y = element_blank()
          )
      }
    )
  # viridis----------------------------------
  if (viridis) {
    p +
      scale_fill_viridis_d(option = viridis_option) +
      scale_colour_viridis_d(option = viridis_option)
  } else {
    p
  }
}

#' @rdname autoplot.predbvhar
#' 
#' @importFrom dplyr bind_rows mutate filter
#' @importFrom ggplot2 ggplot aes facet_grid labs element_blank last_plot ggplot_build geom_path
#' @export
autolayer.predbvhar <- function(object, 
                                ci_fill = "grey70", 
                                ci_alpha = .5,
                                alpha_scale = .3, ...) {
  aes_data <- 
    last_plot() %>% 
    ggplot_build() %>% 
    .$plot %>% 
    .$data # same form as forecast_list above
  x_cut <- aes_data[["id"]][1]
  NEW_list <- 
    gather_predbvhar(object) %>% # new forecast_list
    filter(id >= x_cut)
  geom_predbvhar(
    data = NEW_list %>% filter(forecast == TRUE),
    alpha_scale = alpha_scale,
    ci_param = list(alpha = ci_alpha, colour = NA),
    line_param = list(...)
  )
}

#' Adding Test Data Layer
#' 
#' This function adds a layer of test dataset.
#' 
#' @param data Test data to draw.
#' @param colour Colour of the line (By default, `"red"`).
#' @param num_train `r lifecycle::badge("experimental")` Size of the train data.
#' @param ... Other arguments passed on the [ggplot2::geom_path()].
#' 
#' @importFrom ggplot2 aes geom_path
#' @importFrom dplyr mutate n
#' @importFrom tidyr pivot_longer
#' @export
geom_eval <- function(data, colour = "red", num_train = 1, ...) {
  if (is.matrix(data)) {
    data <- as.data.frame(data)
  }
  if (!is.data.frame(data)) {
    stop("'data' should be a data frame or matrix.")
  }
  if (!all(apply(data, 2, is.numeric))) {
    stop("Every column must be numeric class.")
  }
  new_data <- 
    data %>% 
    mutate(id = 1:n() + num_train) %>% 
    pivot_longer(-id, names_to = "variable", values_to = "value")
  geom_path(
    aes(x = id, y = value),
    data = new_data,
    colour = colour,
    ...
  )
}

#' Compare Lists of Models
#' 
#' Draw plot of test error for given models
#' 
#' @param mod_list Lists of forecast results (`predbvhar` objects)
#' @param y Test data to be compared. should be the same format with the train data and predict$forecast.
#' @param type Loss function to be used (`"mse"`: MSE, `"mae"`: MAE, `mape`: MAPE, `"mase"`: MASE)
#' @param viridis If `TRUE`, scale CI and forecast line using [ggplot2::scale_fill_viridis_d()] and [ggplot2::scale_colour_viridis_d], respectively.
#' @param viridis_option Option for viridis string. See `option` of [ggplot2::scale_colour_viridis_d]. Choose one of `c("A", "B", "C", "D", "E")`. By default, `"D"`.
#' @param ... Additional options for [ggplot2::geom_line()]
#' 
#' @seealso 
#' * [mse()] to compute MSE for given forecast result
#' * [mae()] to compute MAE for given forecast result
#' * [mape()] to compute MAPE for given forecast result
#' * [mase()] to compute MASE for given forecast result
#' 
#' @importFrom dplyr mutate bind_rows
#' @importFrom tidyr pivot_longer
#' @importFrom ggplot2 ggplot aes geom_line labs element_blank scale_colour_viridis_d
#' @export
plot_loss <- function(mod_list, 
                      y, 
                      type = c("mse", "mae", "mape", "mase"), 
                      viridis = FALSE, 
                      viridis_option = "D", ...) {
  type <- match.arg(type)
  mod_names <- 
    mod_list %>% 
    lapply(function(PRED) PRED$process) %>% 
    unlist()
  # error---------------------------------
  SCORE <- 
    switch(
      type,
      "mse" = {
        mod_list %>% 
          lapply(mse, y = y)
      },
      "mae" = {
        mod_list %>% 
          lapply(mae, y = y)
      },
      "mape" = {
        mod_list %>% 
          lapply(mape, y = y)
      },
      "mase" = {
        mod_list %>% 
          lapply(mase, y = y)
      }
    )
  # plot------------------------------------
  p <- 
    SCORE %>% 
    bind_rows() %>% 
    mutate(Model = mod_names) %>% 
    pivot_longer(-Model, names_to = "name", values_to = "score") %>% 
    ggplot(aes(x = name, y = score, colour = Model)) +
    geom_line(aes(group = Model), ...) +
    labs(
      x = element_blank(),
      y = element_blank()
    )
  # viridis----------------------------------
  if (viridis) {
    p +
      scale_colour_viridis_d(option = viridis_option)
  } else {
    p
  }
}
